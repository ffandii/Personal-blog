---
layout: post
title: "V8中的内存控制"
description: "基于无阻塞、事件驱动建立的Node服务，具有内存消耗低的优点，非常适合处理海量的网络请求。在海量请求的前提下，开发者需要考虑一些平常不会形成影响的问题。内存控制正是在海量请求和长时间运行的前提下进行探讨的。"
category: node
tags: [内存控制,v8]
---
{% include JB/setup %}

<div class="p-section">
	<h3>V8的内存限制</h3>
	<p>我们在学习Javascript编程时听说过，它与java一样，由垃圾回收机制进行自动内存管理，这使得开发者不需要像C/C++程序员那样在编写代码的过程中时刻关注内存的分配与释放问题。但在浏览器中进行开发时，几乎很少有人会遇到垃圾回收会对应用程序构成性能影响的情况。Node极大地拓宽了Javascript的应用场景，当主流应用场景从客户端迁移到服务器端之后，我们就能发现，对于性能敏感的服务器端程序，内存管理的好坏、垃圾回收状况是否优良，都会对服务构成影响。而在Node中，这一切都与Node的Javascript执行引擎V8息息相关。</p>
	<p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过Javascript使用内存时就会发现只能使用部分内存（64位操作系统约为1.4GB，32位系统下约为0.7GB）。在这样的限制下，将会导致Node无法直接操作大内存对象，比如无法将一个2GB的文件读入内存中进行字符串分析处理，即使物理内存有32GB。这样在单个Node进程的情况下，计算机内存资源无法得到充足的使用。</p>
	<p>造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的Javascript对象基本上都是通过V8自己的方式进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲的使用大内存的想法。</p>
	<p>尽管在服务器端操作大内存也不是常见的需求场景，但有了这个限制之后，我们的行为就如同带着镣铐跳舞，如果在实际的应用中不小心触碰到这个界限，会造成进程退出。要知道V8为何限制了内存的用量，则需要回归到V8在内存使用上的策略。知晓其原理后，才能避免问题并能更好的进行内存的管理。</p>
</div>

<div class="p-section">
	<h3>V8的对象分配</h3>
	<p>在V8中，所有的Javascript对象都是通过堆来进行分配的。Node中提供了V8中内存的使用量查看方式，执行下面的代码，将得到输出的内存信息：</p>
<pre><code class="javascript">$ node
> process.memoryUsage();
{rss: 14958592,
heapTotal: 7195904,
heapUsed: 2128496}
</code></pre>
	<p>在上述代码中，<code>memoryUsage()</code>方法返回的三个属性中，<code>heapTotal</code>和>code>heapUsed</code>是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。至于<code>rss</code>为何，我们在后续的内容中会介绍到。V8的堆示意图：</p>
	<div class="image"><img src="../../../../../images/post/node/heap.png" width="501" height="133"/></div>
	<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请到的堆空前空间不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制位置。至于V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因为V8的垃圾回收机制的限制。按官方的说法，以1.5GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1s以上。这是垃圾回收中引起Javascript线程暂停执行的时间，在这样的时间花销下，应用额性能与响应能力会直线下降。这样的情况不仅后端服务器无法接受，前端浏览器也无法接受。因此在当时的考虑下，直接限制堆内存是一个好的选择。当然，这个限制也不是不能打开，V8依然提供了选项来让我们使用更多的内存，Node在启动时可以传递<code>--max-old-space-size</code>或<code>--max-new-space-size</code>来调整内存限制的大小，示例如下：</p>
<pre><code class="javascript">node --max-old-space-size=1700 test.js  //单位为MB
//或者
node --max-new-space-size=1024 test.js  //单位为KB
</code></pre>
	<p>上述参数在V8初始化时有效，一旦生效就不能动态改变。如果遇到Node无法分配足够内存给js时，可以用这个办法来放宽V8默认的内存限制，避免在执行过程中稍微多用了一些内存就轻易崩溃。</p>
</div>

<div class="p-section">
	<h3>V8主要的垃圾回收算法</h3>
	<p>V8的垃圾回收策略主要基于分代式垃圾回收机制。在自动垃圾回收演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的
	算法只能针对特定情况具有最好的效果。为此统计学在垃圾回收算法的发展中产生了较大的作用，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行分代，然后分别对不同分代的内存施以更高效的算法。</p>
	<h4></h4>
</div>